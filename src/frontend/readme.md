# Общая структура
Фронтенд разрабатывается с использованием методологии ООП без использования какого-либо фреймворка. В качестве архитектурного решения используется [классическая модель MVC](https://developer.chrome.com/apps/app_frameworks):

![Схема модели MVC](https://developer.chrome.com/static/images/mvc.png)

 - модель хранит данные и бизнес-логику
 - вид обеспечивает отображение (НТМL, CSS) и доступ к событиям пользовательского интерфейса
    - при использовании сторонних библиотек для организации взаимодействия с пользователем обеспечивает абстракцию этого взаимодействия для контроллера
 - контроллер связывает модель и вид:
    - подписывается на события модели и передает данные в вид
    - подписывается на события вида и передает данные в модель
    - обеспечивает связь с маршрутизатором

В качестве шаблона для разработки классов используется [OLOO](https://john-dugan.com/object-oriented-javascript-pattern-comparison/#oloo-pattern):
```
//класс
var BaseClass = {
    init: function (param) {
        ...
    },
    someFunc: function (param) {
        ...
    }
};

//создание экземпляра класса
var instance = Object.create(BaseClass);
instance.init(someParam);

//дочерний класс
var ChildClass = Object.assign(Object.create(BaseClass), {
    someFunc: function (param) {
        ...другая реализация...
    },
    
    someOtherFunc: function (param) {
        ...дополнительная функция...
    }
});

//композиция
var Child = {
...
};

Child = Object.assign(Child, ParentA);
Child = Object.assign(Child, ParentB);
```

Более подробно можно почитать по ссылкам:
 - https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch6.md#mental-models-compared
 - https://john-dugan.com/object-oriented-javascript-pattern-comparison/

Проект разбивается на модули с использованием шаблона [CommonJS](https://nodejs.org/docs/latest/api/modules.html), собирается при помощи [Webpack](http://webpack.github.io/) (есть скрипт `build.sh`). Тестирование проводится при помощи [Jest](https://facebook.github.io/jest/) (есть скрипт `test.sh`).

# Контроллеры, обработка событий
Для каждой страницы свой контроллеров, а если страница очень большая, то на ней их может быть несколько. Контроллеры связаны между собой маршрутизатором (предлагаю [page.js](https://github.com/visionmedia/page.js) или [crossroads.js](https://millermedeiros.github.io/crossroads.js/)).

В качестве шины для передачи событий используется DOM (для моделей используется виртуальный DOM-элемент внутри). Объекты, слушающие события реализуют интерфейс [EventListener](https://developer.mozilla.org/ru/docs/Web/API/EventListener): это позволяет не отслеживать повторяющиеся события и потерявшиеся callback-функции обработки событий.
Интересный материал по теме: [https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38](https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38)

Для всех контроллеров сделан базовый класс `controllers/base.js` (однако его можно не использовать по необходимости).

# Модели
Модели хранят данные и бизнес-логику, их связывающую. Обеспечивают согласованность устанавливаемых и расчитываемых полей.
Модели реализуют [интерфейс EventTarget](https://developer.mozilla.org/ru/docs/Web/API/EventTarget), т.к. они могут генерировать события, связанные с изменением данных.
Если модель загружается по сети, то она не запускает события, связанные с изменением каждого загруженного поля, а запускает общее событие load. Это следует учитывать при разработке контроллеров, которые должны это событие обрабатывать отдельно. Это делается для того, чтобы избежать лишних обновлений (при загрузке модели может быть легче отрисовать компонент заново).

Для всех моделей сделан базовый класс - `models/base.js` (однако его можно не использовать по необходимости).

# Немного о событиях
Обработчики событий вызываются в той последовательности, в которой они были добавлены при помощи функции `addEventListener`. Ввиду (почти) однопоточной структуры JavaScript время выполнения обработчика не влияет на порядок завершения обработки. Аналогично с повторным вызовом обработчиков:
```
model.set('1');
model.set('2');
```
Если на set назначена отрисовка вида, то можно быть уверенным в том, что порядок не будет перепутан и '2' будет последним. См. `models/Base.test.js`.
Исключение составляет загрузка модели, которая проходит асинхронно и два подряд идущих вызова могут завершиться в произвольной последовательности. При реализации функций загрузки следует учитывать это и не допускать повторного запуска процедуры загрузки, если она уже запущена. См. `models/Osago.js`

# Вид
Задача вида - сформировать HTML, CSS и присоединить все к DOM. Глобальные стили (reset, шрифты и пр.) формируются во входной точке приложения (`index.js`). Это осуществляется при помощи функции `render`. Так же вид может реализовывать функцию `getDOM`, которая возвращает сформированный HTML-код без подключения его к DOM - это полезно для реализации иерархии видов.

DOM удобно формировать при помощи библиотеки [hyperscript](https://github.com/hyperhype/hyperscript), которая реализует удобную обертку вокруг браузерных интерфейсов создания элементов (на выходе из hyperscript получается [HTMLElement](https://developer.mozilla.org/ru/docs/Web/API/HTMLElement)).

CSS формируется непосредственно в компоненте при помощи библиотеки [jss](http://cssinjs.org/) - она позволяет формировать css без дополнительных движков непосредственно из кода.

# Тестирование
Модульные тесты на различные компоненты располагаются в тех же папках, что и сами компоненты, которые они тестируют. В названии модульных тестов используется префикс `.test`. Например: `Base.js` - компонент, `Base.test.js` - тест этого компонента.

Для написания и прогона тестов используется [Jest](https://facebook.github.io/jest/). Посмотреть информацию по написанию тестов при помощи Jest можно тут: https://facebook.github.io/jest/docs/en/getting-started.html

# Дополнительные библиотеки
Подключать к проекту новые библиотеки нужно по неоходимости. Нужно отдавать предпочтение небольшим библиотекам, не брать из них лишнего.

# Соглашение по именованию
## Классы и переменные
 * Классы именуются с БольшойБуквы (UpperCamelCase), экземпляры - с маленькойБуквы (lowerCamelCase)
 * Переменные, функции именуются с маленькойБуквы (lowerCamelCase)
 
## Функции
Название функции, должно содержать глагол, который показывает, что конкретно функция делает. Из общих глаголов предлагается использовать следующие:
 * `get*` - функция возвращает значение, которое откуда-то достала. Ничего не устанавливает (`getColor`)
 * `set*` - функция устанавливает какой-то параметр в новое значение. Ничего не возвращает (`setVehicle`)
 * `query*` - делает какой-то запрос и возвращает результат, аналог `get*` для DOM (`queryNumberInput`)
 * `update*` - обновляет какой-то визуальный элемент, аналог `set*` для DOM (`updateCounter`)
 * `render*` - создает визуальное представление чего-либо и размещает его в DOM (`renderForm`) 
 * `handle*` - обрабатывает какое-то событие (`handleEsiaButtonClick`)
 * `create*` - создает какой-то новый объект и возвращает его (`createVehicle`)
 * `make*` - создает какое-то значение и возвращает его (`makeUrl`)
 * `init*` - задает начальное состояние чего-то (`initFields`)

Помимо указанных глаголов можно использовать любые другие, отражающие суть действия (`switchLight`, `polishCar`, `toggleIndicator`, `fetchData` и пр.)

## Файлы
 * Файлы классов именуются с большой буквы, прочие файлы - с маленькой
 * Файлы тестов классов именуются с большой буквы, прочие тесты - с маленькой

### Иерархия файлов
```
public/                 публичные файлы
src/frontend/           исходные файлы приложения
    classes/            вспомогательные классы
    controllers/        контроллеры
    mocks/              заглушки для тестирования
    models/             модели
    styles/             классы с библиотекой стилей приложения
    views/              виды
```